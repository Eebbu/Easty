# 天杀的 6442 assignment report

# Application Description：

插入search page:
On this page, users can search for any food they want and choose how to get the food (i.e. donate, wanted and exchange).
When the user types in the food they want and selects any option, our app will retrieve the relevant data from the firebase database and display it.
When the user types in the food they want and selects any option, our app will retrieve the relevant data from the firebase database and display it.

插入search之后的page：apple

When the user types apple and selects the donate type, our app will pick up the post_type as donate from firebase, and apple's post will appear in the post_title.

插入search之后的page:butter chicken
When the user types apple and selects the exchange and donate types, our app will pick up the post_type as donate and exchange from firebase, and the post_title of butter chicken will appear.
插入search之后的page：I want a banana
When the user types want and selects the wanted type, our app will pick up the post_type as wanted from firebase, and the post I or want or a or banana will appear in the post_title.
插入点进详情页的page：
When we click on any post under the search term, we can see the specific content of the post. 

# Code Design and Decisions

## Tokenizer and parser

### **Parser**

**Grammar(s)**

The grammar used in our project is designed to parse text consisting of space-separated words. The parser constructs a parse tree where each node represents a word and its children represent the words that follow it in the sequence.

**Advantages of the design**:

- **Simplicity**: The grammar is simple and straightforward, making it easy to implement and debug.
- **Extensibility**: While the current grammar is simple, it can be extended to include more complex features such as handling different types of tokens or incorporating operator precedence without a complete overhaul.

**Production Rules**:

- **Expression**::= Term { " " Term }
- **Term**::= Word

**Term** represents individual words, and **Expression** represents sequences of these words. An expression consists of one or more terms separated by spaces.

### **Tokenizers and Parsers**

**Usage**:

- **Tokenizers**: The tokenizer in my project breaks down the input string into tokens based on spaces. Each token is either a word or a space. This tokenizer is utilized in the **matchToken**function within **Search** class to preprocess the input for parsing.
- **Parsers**: The parser is used to construct a parse tree from the sequence of tokens generated by the tokenizer. It processes the tokens to build a hierarchical structure that represents the sequence in which words appear in the input.

**Construction**: 

**Tokenizer**: It is implemented using simple string operations. The input string is split using the space character as a delimiter, generating an array of words which are then individually wrapped as **Token**

- **Parser**: The parser is implemented as a recursive descent parser. It starts by creating a node for the first token and then recursively processes the following tokens to build the tree. The recursive nature of the parser allows it to easily handle nested or sequential structures typical in language constructs.

**Advantages of the designs**:

- **Efficiency**: The tokenizer is efficient as it leverages built-in string methods which are optimized for performance.
- **Flexibility**: The parser is designed to be flexible and can be easily adjusted or extended to support more complex grammatical structures if needed.
- **Modularity**: The separation of tokenizing and parsing functions enhances modularity. This makes the code easier to manage and test, as each component can be developed and debuged independently.

**Scalability**: The parser uses recursive methods, making it scalable for extending the grammar without significantly altering the existing codebase. This is beneficial for maintaining and upgrading the system in the future.

# Choice of data structure

HashMap

- Objective: Used for storing and quickly accessing `Post` objects by their IDs within the `StorageList` class.
- Code Location: Defined in `StorageList` class. Utilized in methods such as `initPostData` and `initLocalData` to store and access `Post` instances.
- Reasons:
- Efficiency: `HashMap` offers O(1) time complexity for insertions and lookups, which is more efficient than an `ArrayList` for these operations.
- Key-value Access: For features like updating or retrieving `Post` data, direct access via post IDs (keys) is essential, eliminating the need for indexing which is crucial for performance.

 ArrayList

- Objective: Used for storing lists of `Post` objects in a dynamically resizing array format, suitable for ordered collection which also supports random access.
- Code Locations: Utilized in `StorageList` and `Search` classes, particularly in methods like `initPostData` and `searchAll` for storing and managing collections of posts.
- Reasons:
- Random Access: Unlike `LinkedList`, `ArrayList` provides efficient random access to elements, which is beneficial where elements are frequently accessed by index.

### HashSet

- Dynamics and Performance: Better performance in terms of memory as it stores items in a contiguous memory space and is generally faster in iterating over elements compared to `LinkedList`.
- Objective: Used in the `Search` class to ensure uniqueness and efficient lookup for `Post` objects when performing search operations.
- Code Locations: Used in the `searchByTest` method of the `Search` class to store unique results from keyword-based searches.
- Reasons:
- Uniqueness: Automatically prevents duplication of `Post` objects in search results.
- Efficiency: Offers O(1) complexity for add and check operations, ideal for scenarios where the integrity of uniqueness is more critical than ordering.

AVLTree

- Objective: Utilized to maintain a balanced search tree of `Post` objects, ensuring efficient order operations and balanced tree properties for quick search and retrieval.
- Code Locations: `StorageList` class uses `AVLTree` to manage posts in a sorted manner, particularly evident in the `buildTree` and `traverseTree` methods.
- Reasons:
- Balanced Search Operations: `AVLTree` maintains balance with rotations, providing O(log n) complexity for insertions, deletions, and searches.
- Ordering: Maintains elements in a sorted order, which is beneficial for range queries and ordered data retrieval operations.

# Design Pattern

Adapter Pattern
Objective: Allows objects with incompatible interfaces to collaborate.
Code Locations: Used in the ListDataAdapter class, which adapts a list of Post objects to be usable in a ListView which expects data in a specific format.
Reasons:
Interface Compatibility: Converts the interface of the List<Post> into the interface expected by the ListView, enabling seamless integration of complex data structures with UI components.
Reusability: Allows the same Post data to be reused in different list-based UI components without modifying the underlying data structure or the components themselves.

Builder Pattern
Objective: Separates the construction of a complex object from its representation so that the same construction process can create different representations.
Code Locations: Used in constructing complex Post objects, in scenarios where a Post object consists of various discrete parts that are assembled step-by-step.
Reasons: Step-by-step Construction: Allows for constructing complex objects step-by-step, particularly useful when creating an object requires setting many attributes that could be optional.

# Search(Medium)

Objective: Created an activity for searching and filtering posts within the application, utilizing various data structures and methods to efficiently manage and display search results.

Code:

Class: Search

Key Methods: onCreate, setCheckListener, setEditListener, searchData, searchAll, searchByTest

Related Classes: StorageList, ListDataAdapter, AVLTree, AVLTreeNode, Trie, TrieNode

Description of Implementation:

The Search activity is designed to process user input for searching and filtering posts based on categories like "Donate", "Need", and "Exchange". The functionality is extended by integrating Firebase Firestore to fetch real-time data, ensuring up-to-date information is always available.

Main Features:

Dynamic Filtering: Users can filter search results in real-time by selecting different categories through checkboxes. The application updates the displayed results immediately based on the selected criteria.

Keyword Search: Includes an input field where users can type keywords. The application parses these inputs to filter posts containing relevant information. This feature uses a custom tokenizer and parser to handle the input strings efficiently.

Data Structure Usage:

HashMap: Used to store and quickly retrieve posts by unique identifiers.

ArrayList: Manages lists of posts for display and intermediate operations.

HashSet: Ensures unique search results, preventing duplicate entries in the display.

AVLTree: Maintains posts in a balanced manner to optimize search and retrieval operations based on sorted or ranked criteria.

Performance Considerations:

The use of efficient data structures like HashMap and AVL Tree ensures that search operations are fast and responsive, even with a large dataset.
The Singleton pattern in StorageList minimizes redundancy in data management, thereby improving memory usage and speed.

Security and Data Integrity:

All interactions with Firebase are managed through secure authenticated sessions, ensuring that data retrieval and manipulation are protected against unauthorized access.

This implementation not only fulfills the basic requirements of a search feature but also enhances user experience through quick responsiveness and accurate results. The modular approach in designing the Search class allows for easier maintenance and scalability, adapting to potential future enhancements like more complex search algorithms or additional filtering criteria.

[Search-Invalid](https://www.notion.so/Medium): Handling Partially Valid and Invalid Search Queries
Objective: Enhance the search functionality to handle both partially valid and invalid search queries effectively without causing the application to crash, while still providing meaningful search results based on valid parts of the query.

Subject: Partially valid and invalid search query handling.

Description: The search feature of the application is designed to robustly handle errors in user input, ensuring that the application remains stable and responsive even when faced with partially valid or invalid search queries. The feature aims to parse user inputs and extract usable information to return the best possible results.

What the feature entails:
Modifying the Tokenizer/Parser: The application's tokenizer and parser have been enhanced to more effectively identify and separate valid elements from invalid inputs. This allows the application to process and respond to mixed-quality queries by ignoring or flagging invalid tokens while utilizing valid tokens for search operations.
Error Handling Mechanisms: Implementations include try-catch blocks, input validation, and error logging to manage unexpected or malformed inputs gracefully.
Feedback to Users: When invalid inputs are detected, the application provides feedback to the user, suggesting corrections or clarifying what parts of the query were processed.
Feature Relevance: Tokenization and parsing are crucial for dissecting user input into manageable components that the system can understand and process, which is central to this feature.

Search-Filter: Sorting and Filtering Search Results
Objective: Implement functionality to sort and filter the list of items returned from searches, utilizing suitable UI components to allow users to refine their search results dynamically.

Subject: Advanced sorting and filtering of search results.

Description: This feature allows users to sort and filter search results based on various criteria such as date, relevance, type, etc. The implementation includes UI components that users interact with, such as dropdowns, checkboxes, and sliders, to adjust the filtering parameters dynamically.

What the feature entails:
Dynamic UI Components: Implement dropdown menus for sorting (e.g., ascending, descending), checkboxes for filtering specific types of posts (e.g., donations, requests), and sliders for range selections (e.g., date ranges, quantities).
Backend Logic: Enhance the search mechanism to respond to these filters, sorting the internal data structures like ArrayLists and updating the display according to user preferences.
Live Updates: The search results update in real-time as users adjust the filters, providing an interactive and responsive user experience.
Feature Relevance: The ability to sort and filter enhances the usability of the search function, allowing users to more easily navigate large sets of data and find the items that best match their needs.